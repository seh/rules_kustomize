# We must accommodate loading this file from repositories generated by
# our repository rules.
visibility("public")

_TOOLS_BY_RELEASE = {
    "v5.8.1": {
        struct(os = "darwin", arch = "amd64"): "ee7cf0c1e3592aa7bb66ba82b359933a95e7f2e0b36e5f53ed0a4535b017f2f8",
        struct(os = "darwin", arch = "arm64"): "8886f8a78474e608cc81234f729fda188a9767da23e28925802f00ece2bab288",
        struct(os = "linux", arch = "amd64"): "029a7f0f4e1932c52a0476cf02a0fd855c0bb85694b82c338fc648dcb53a819d",
        struct(os = "linux", arch = "arm64"): "0953ea3e476f66d6ddfcd911d750f5167b9365aa9491b2326398e289fef2c142",
        struct(os = "windows", arch = "amd64"): "8ec7f5e815e526d4622c06df0a7793d8cfb6eb1c74f816b46166097fef8b26c6",
        struct(os = "windows", arch = "arm64"): "f6f5090c373965760a30a59af84c81853b80d2c7dbb3236424f440e47eed3f5a",
    },
    "v5.8.0": {
        struct(os = "darwin", arch = "amd64"): "2deaa6f96450c0b3204cccd9f159a22278eb6cf85ad545d212d608d2428aeb57",
        struct(os = "darwin", arch = "arm64"): "d098f62ecda500c752303163838af823f947d245927f3000b629199c1eeeae0f",
        struct(os = "linux", arch = "amd64"): "4dfa8307358dd9284aa4d2b1d5596766a65b93433e8fa3f9f74498941f01c5ef",
        struct(os = "linux", arch = "arm64"): "a4f48b4c3d4ca97d748943e19169de85a2e86e80bcc09558603e2aa66fb15ce1",
        struct(os = "windows", arch = "amd64"): "7779999c8eb7bdbbaa55c6ecf4fadfdbe7508199ea189f06862835e7e5cb1e41",
        struct(os = "windows", arch = "arm64"): "a08acc2b1191f7bd192f31ed7ee1c0a5a743228a21ac239862248a47f800a016",
    },
    "v5.7.1": {
        struct(os = "darwin", arch = "amd64"): "4a0dff80c5644df6bc8f51b342842969004cb6ba5f94dddaabbea7483493273d",
        struct(os = "darwin", arch = "arm64"): "073e9d16d5a235e2ff83e62d6b76edb5d962adbc33be1e4860c4b3f1f39b33b9",
        struct(os = "linux", arch = "amd64"): "ea375e7372f9aa029129d4b2d16c66b7750b7f1213c4f66f910d981c895818d8",
        struct(os = "linux", arch = "arm64"): "4261a040217df3bd6896597c3986d1465925726e4f22a945304b5233a4dcdbda",
        struct(os = "windows", arch = "amd64"): "4704f8b47582c1c52bf76a50b37178f7f7de17f892713794a8bf44b01b50e0ce",
        struct(os = "windows", arch = "arm64"): "d838872ffd5efcd240e6b308a7899b2bb537352b2eb99a6b3fbb023df9ca7c0d",
    },
    "v5.7.0": {
        struct(os = "darwin", arch = "amd64"): "277a7401f969ce3945e8f0ff8b0cce6f4353854db1ff89ba070001e3246e7f22",
        struct(os = "darwin", arch = "arm64"): "c0dac68dc7870e1f673ae4d8fb554df971e0b9b9f0affc4be4c0852f62d0796e",
        struct(os = "linux", arch = "amd64"): "0d98f06d6d2c2c0ff8923cc136a517af74aaa187f1b9f3e17ff370d0625ede84",
        struct(os = "linux", arch = "arm64"): "744bb1bc1854b6634dea9eaf6db2f401a734ed25d6837baa6f91157d79c27d5e",
        struct(os = "windows", arch = "amd64"): "eacee576f22e8c0cb1ff2840ec6496aa42346d5a23936fed9899f7019ed2af62",
        struct(os = "windows", arch = "arm64"): "acb94b010781663abe4ffce7d674da31a644c6df9839f73fa6711d5fe13574c0",
    },
    "v5.6.0": {
        struct(os = "darwin", arch = "amd64"): "3432be97f9fb4899148bf2485ccf9080e5e7702758eb16c92cd2f2f335e12a03",
        struct(os = "darwin", arch = "arm64"): "791d9497d2973d4af17c9c0c2b3991ce82e61d1a2bf79f4ef78dd9dce25a6d3d",
        struct(os = "linux", arch = "amd64"): "54e4031ddc4e7fc59e408da29e7c646e8e57b8088c51b84b3df0864f47b5148f",
        struct(os = "linux", arch = "arm64"): "ad8ab62d4f6d59a8afda0eec4ba2e5cd2f86bf1afeea4b78d06daac945eb0660",
        struct(os = "windows", arch = "amd64"): "f21d94e9660b4f11a47c4fdc26b936d513f8aada879e5c53553abd27369ef3a1",
        struct(os = "windows", arch = "arm64"): "4e55c1b175659fffea12552acc3d748387ecb49808b10458b5c9173777d70239",
    },
    "v5.5.0": {
        struct(os = "darwin", arch = "amd64"): "874224e75229821b1e571aefa45703789b77336302a34692eac65adbe0dc1cee",
        struct(os = "darwin", arch = "arm64"): "5baa407bdaee51b97626ef1fca3292e1a1c846357d3028db826057ecceed7178",
        struct(os = "linux", arch = "amd64"): "6703a3a70a0c47cf0b37694030b54f1175a9dfeb17b3818b623ed58b9dbc2a77",
        struct(os = "linux", arch = "arm64"): "b4170d1acb8cfacace9f72884bef957ff56efdcd4813b66e7604aabc8b57e93d",
        struct(os = "windows", arch = "amd64"): "a19684ae51f7a768f937f713780411cfb3945339a509294504daf9b87a77b642",
        struct(os = "windows", arch = "arm64"): "2e5c0072a048ecddb95d6d7489b90f773a6f325b36ac9892f541d0fd26421a43",
    },
}

_DEFAULT_TOOL_VERSION = "v5.8.1"

def known_release_versions():
    return _TOOLS_BY_RELEASE.keys()

KustomizeInfo = provider(
    doc = "Details pertaining to the Kustomize toolchain.",
    fields = {
        "tool": "Kustomize tool to invoke",
        "version": "This tool's released version name",
    },
)

KustomizeToolInfo = provider(
    doc = "Details pertaining to the Kustomize tool.",
    fields = {
        "binary": "Kustomize tool to invoke",
        "version": "This tool's released version name",
    },
)

def _kustomize_tool_impl(ctx):
    return [KustomizeToolInfo(
        binary = ctx.executable.binary,
        version = ctx.attr.version,
    )]

kustomize_tool = rule(
    implementation = _kustomize_tool_impl,
    attrs = {
        "binary": attr.label(
            mandatory = True,
            allow_single_file = True,
            executable = True,
            cfg = "exec",
            doc = "Kustomize tool to invoke",
        ),
        "version": attr.string(
            mandatory = True,
            doc = "This tool's released version name",
        ),
    },
)

def _toolchain_impl(ctx):
    tool = ctx.attr.tool[KustomizeToolInfo]
    toolchain_info = platform_common.ToolchainInfo(
        kustomizeinfo = KustomizeInfo(
            tool = tool.binary,
            version = tool.version,
        ),
    )
    return [toolchain_info]

kustomize_toolchain = rule(
    implementation = _toolchain_impl,
    attrs = {
        "tool": attr.label(
            mandatory = True,
            providers = [KustomizeToolInfo],
            cfg = "exec",
            doc = "Kustomize tool to use for building kustomizations.",
        ),
    },
)

# buildifier: disable=unnamed-macro
def declare_kustomize_toolchains(kustomize_tool):
    for version, platforms in _TOOLS_BY_RELEASE.items():
        for platform in platforms.keys():
            kustomize_toolchain(
                name = "{}_{}_{}".format(platform.os, platform.arch, version),
                tool = kustomize_tool,
            )

def _translate_host_platform(ctx):
    # NB: This is adapted from rules_go's "_detect_host_platform" function.
    os = ctx.os.name
    if os == "mac os x":
        os = "darwin"
    elif os.startswith("windows"):
        os = "windows"

    arch = ctx.os.arch
    if arch == "aarch64":
        arch = "arm64"
    elif arch == "x86_64":
        arch = "amd64"

    return os, arch

_MODULE_REPOSITORY_NAME = "rules_kustomize"
_CONTAINING_PACKAGE_PREFIX = "//kustomize/private/tools/kustomize"

def _download_tool_impl(ctx):
    if not ctx.attr.arch and not ctx.attr.os:
        os, arch = _translate_host_platform(ctx)
    else:
        if not ctx.attr.arch:
            fail('"os" is set but "arch" is not')
        if not ctx.attr.os:
            fail('"arch" is set but "os" is not')
        os, arch = ctx.attr.os, ctx.attr.arch
    version = ctx.attr.version
    extension = ".zip" if os == "windows" else ".tar.gz"

    sha256sum = _TOOLS_BY_RELEASE[version][struct(os = os, arch = arch)]
    if not sha256sum:
        fail('No Kustomize tool is available for OS "{}" and CPU architecture "{}" at version {}'.format(os, arch, version))
    ctx.report_progress('Downloading Kustomize tool for OS "{}" and CPU architecture "{}" at version {}.'.format(os, arch, version))
    ctx.download_and_extract(
        url = "https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize%2F{version}/kustomize_{version}_{os}_{arch}{extension}".format(
            arch = arch,
            extension = extension,
            os = os,
            version = version,
        ),
        sha256 = sha256sum,
    )

    ctx.template(
        "BUILD.bazel",
        Label("{}:BUILD.tool.bazel".format(_CONTAINING_PACKAGE_PREFIX)),
        executable = False,
        substitutions = {
            "{containing_package_prefix}": "@{}{}".format(_MODULE_REPOSITORY_NAME, _CONTAINING_PACKAGE_PREFIX),
            # NB: In version 5.2.1, the released tools built for
            # Windows lacked an extension. Other releases use the
            # conventional ".exe" extension.
            "{extension}": ".exe" if os == "windows" and version != "v5.2.1" else "",
            "{version}": version,
        },
    )
    return None

_download_tool = repository_rule(
    implementation = _download_tool_impl,
    attrs = {
        "arch": attr.string(),
        "os": attr.string(),
        "version": attr.string(
            values = _TOOLS_BY_RELEASE.keys(),
            default = _DEFAULT_TOOL_VERSION,
        ),
    },
)

# buildifier: disable=unnamed-macro
def declare_bazel_toolchains(version, toolchain_prefix):
    native.constraint_value(
        name = version,
        constraint_setting = "{}:tool_version".format(_CONTAINING_PACKAGE_PREFIX),
    )
    constraint_value_prefix = "@{}//kustomize/private/tools".format(_MODULE_REPOSITORY_NAME)
    for platform in _TOOLS_BY_RELEASE[version].keys():
        native.toolchain(
            name = "{}_{}_{}_toolchain".format(platform.os, platform.arch, version),
            exec_compatible_with = [
                "{}:cpu_{}".format(constraint_value_prefix, platform.arch),
                "{}:os_{}".format(constraint_value_prefix, platform.os),
            ],
            toolchain = toolchain_prefix + (":{}_{}_{}".format(platform.os, platform.arch, version)),
            toolchain_type = "@{}//tools/kustomize:toolchain_type".format(_MODULE_REPOSITORY_NAME),
        )

def _toolchains_impl(ctx):
    ctx.template(
        "BUILD.bazel",
        Label("{}:BUILD.toolchains.bazel".format(_CONTAINING_PACKAGE_PREFIX)),
        executable = False,
        substitutions = {
            "{containing_package_prefix}": "@{}{}".format(_MODULE_REPOSITORY_NAME, _CONTAINING_PACKAGE_PREFIX),
            "{tool_repo}": ctx.attr.tool_repo,
            "{version}": ctx.attr.version,
        },
    )

_toolchains_repo = repository_rule(
    implementation = _toolchains_impl,
    attrs = {
        "tool_repo": attr.string(mandatory = True),
        "version": attr.string(
            values = _TOOLS_BY_RELEASE.keys(),
            default = _DEFAULT_TOOL_VERSION,
        ),
    },
)

def download_tool(name, version = None):
    _download_tool(
        name = name,
        version = version,
    )
    _toolchains_repo(
        name = name + "_toolchains",
        tool_repo = name,
        version = version,
    )
